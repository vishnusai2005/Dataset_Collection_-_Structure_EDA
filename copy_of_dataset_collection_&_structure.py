# -*- coding: utf-8 -*-
"""Copy of Dataset_Collection_&_Structure.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mrk4JdIpIqUbWid6B1RRBllgBtuelQYu

## Problem Statement

The IPL is a fast-paced T20 league, and understanding match trends can be complex. This project analyzes **ball-by-ball data (2008-2023)** to explore **batting, bowling, match results, and venue impact** using **Exploratory Data Analysis (EDA)** to uncover key insights.

## **Dataset Info:**

**Match ID** : Unique identifier for each match.

**Date**: Date on which the match was played.

**Venue** : Name of the stadium where the match was played.

**Bat First** : Name of the team that batted first.

**Bat Second** : Name of the team that batted second.

**Innings** : Indicates the inning number (1 or 2) of the match.

**Over** : Specifies the over number within the inning.

**Ball** : Denotes the ball number within the over.

**Batter** : Name of the batsman facing the delivery.

**Non Striker** : Name of the non-striking batsman.

**Bowler** : Name of the bowler delivering the ball.

**Batter Runs** : Runs scored by the batsman on that specific delivery.

**Extra Runs** : Additional runs awarded due to extras like wides or no-balls.

**Runs From Ball** : Total runs scored from that delivery (batsman + extras).

**Ball Rebowled** : Indicator if the ball was rebowled (e.g., after a no-ball).

**Extra Type** : Type of extra run conceded (e.g., wide, no-ball, leg bye, bye).

**Wicket** : Indicates if a wicket fell on that delivery (1 for yes, 0 for no).

**Method** : Type of dismissal (e.g., bowled, caught, run out, etc.).

**Player Out** : Name of the dismissed player, if applicable.

**Innings Runs** : Total runs scored in the inning up to that ball.

**Innings Wickets** : Total number of wickets lost in the inning up to that ball.

**Target Score** : The target score set by the batting team (useful in chases).

**Runs to Get** : Runs required to win the match (only in chases).

**Balls Remaining** : Number of balls left in the innings.

**Winner** : Name of the team that won the match.

**Chased Successfully** : Indicator if the target was successfully chased (1 for yes, 0 for no).

**Total Batter Runs** : The total runs accumulated by the batter up until this delivery in the innings

**Total Non Striker Runs** : The total runs accumulated by the non-striker up until this delivery in the innings

**Batter Balls Faced** : The number of valid deliveries faced by the batter up until this delivery in the innings.

**Non Striker Balls Faced** : The number of valid deliveries faced by the non-striker up until this delivery in the innings.

**Player Out Runs** : The total runs scored by the dismissed player before getting out

**Player Out Balls Faced** : The number of valid deliveries faced by the dismissed player before getting out

**Bowler Runs Conceded** : Total runs conceded by the bowler in that ball.

**Valid Ball** : Indicates if the delivery was a valid ball (not wide/no-ball).

## **Import Libraries**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

import warnings
warnings.filterwarnings('ignore')

"""## **Load Data**"""

df = pd.read_csv('/content/ball_by_ball_ipl.csv', index_col = 0)

"""### **Dataset Overview & Structure**"""

df.head(10)

df.tail()

df.shape

"""#### **Identifying key columns and understanding data types**"""

df.columns

df.info()

df.dtypes

df.size #it will gives non nan or null element

"""**DATA CLEANING**

**Standardizing Categorical values**

Before moving to analysis, ensure data consistency in categorical values:
Checking key categorical columns prevents errors in grouping, filtering, and aggregations
"""

categorical_columns = df.select_dtypes(include= ['object','category']).columns.tolist()

df['Venue'].unique()

venue_map = {
    "M.Chinnaswamy Stadium": "M Chinnaswamy Stadium",
    "Sardar Patel Stadium": "Narendra Modi Stadium",
    "Punjab Cricket Association IS Bindra Stadium": "Punjab Cricket Association Stadium",
    "Feroz Shah Kotla": "Arun Jaitley Stadium",
    "Zayed Cricket Stadium": "Sheikh Zayed Stadium",
    "De Beers Diamond Oval": "Kimberley Oval",
    "Rajiv Gandhi International Stadium": "Uppal Stadium",
    "Dr Y.S. Rajasekhara Reddy ACA-VDCA Cricket Stadium": "ACA-VDCA Stadium",
    "Shaheed Veer Narayan Singh International Stadium": "Raipur International Cricket Stadium",
    "JSCA International Stadium Complex": "Ranchi Stadium",
    "Barsapara Cricket Stadium": "Assam Cricket Association Stadium"
}

df['venue'] = df['Venue'].replace(venue_map)

df['Bat First'].unique()



df['Bat Second'].unique()

df['Winner'].unique()

team_name_map = {
    "Delhi Daredevils": "Delhi Capitals",
    "Kings XI Punjab": "Punjab Kings"
}
df['Bat First'] = df['Bat First'].replace(team_name_map)
df['Bat Second'] = df['Bat Second'].replace(team_name_map)
df['Winner'] = df['Winner'].replace(team_name_map)

"""**CLEANING PLAYER NAMES**"""

df['Batter'].unique()

df['Batter'] = df['Batter'].str.strip().str.title() #str.strip removes the spaces between starting and ending of a string
#title makes the first letter as capital in each word
df['Non Striker'] = df['Non Striker'].str.strip().str.title()
df['Bowler'] = df['Bowler'].str.strip().str.title()
df['Player Out'] = df['Player Out'].str.strip().str.title()

"""**HANDLING MISSING & DUPLICATED DATA**"""

df.info() #check the method and some other doesnt have values

df.isna().sum() #sum will see the True where is present if true means it will sum it and it will represent the sum of missing/empty/undefined value in the dataset

"""**OBSERVATIONS**

* **Method** has **227,866 missing values** because it is only applicable when a wicket falls. It is **NaN for deliveries where no wicket fell**.  
* **Player Out** has **227,866 missing values** as it is recorded only when a wicket falls, making it **NaN for non-wicket deliveries**.  
* **Player Out Runs** has **227,866 missing values** because it is missing for deliveries where no player was out.  
* **Player Out Balls Faced** has **227,866 missing values** for the same reason—it is recorded only when a player gets out.  
* **Runs to Get** has **123,927 missing values** as it is **only relevant for the second innings**, making it **NaN for the first innings**.
"""

df.dropna()

df['Method'].fillna('Not Out', inplace = True) #here inplace = True will modify the orginal column/series
df['Player Out'].fillna('None', inplace = True) #if the player is not out the value will be empty instaed of it we will replace with None
df['Player Out Runs'].fillna(0, inplace = True) #if that particular ball is the player is not out we will put 0
df['Player Out Balls Faced'].fillna(0, inplace = True)

"""**CHECK FOR DUPLICATES**"""

df.duplicated().sum()#check the each row if the row is seen before in the dataset return true else false

"""**DATA TYPE CORRECTIONS**

**Match ID** should be converted from **int64** to **str** because it represents a categorical value, not a numerical one.

**Date** should be converted from **object** to **datetime64** since it is needed for time-series analysis.

**Ball Reboweled** should be converted from **int64** to **bool** by mapping 1 → True and 0 → False.

**Runs to Get** should be converted from **float64** to **int64** because runs are always whole numbers.

**Player Out Runs** should be converted from **object** to **int64** because it should be a numeric column.

**Player Out Balls** Faced should be converted from **float64** to **int64** because it should be an integer.
"""

df['Match ID'] = df['Match ID'].astype(str)
df['Ball Rebowled'] = df['Ball Rebowled'].astype(bool)
df['Runs to Get'].fillna(0, inplace=True)
df['Runs to Get'] = df['Runs to Get'].astype(int)
df['Player Out Runs'].fillna(0, inplace=True)
df['Player Out Runs'] = df['Player Out Runs'].astype(int)
df['Player Out Balls Faced'].fillna(0, inplace=True)
df['Player Out Balls Faced'] = df['Player Out Balls Faced'].astype(int)
df['Date'] = pd.to_datetime(df['Date'])